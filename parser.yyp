%{
    #include <iostream>
    #include "output.hpp"
    using namespace std;
    #define YYSTYPE Node*
    int yylex();
    void yyerror(const char*);
%}

//TODO: Not sure if the line below is legal
%option yylineno
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token AND
%token OR
%token NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%right ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE
%token ASSIGN
%token RELOP
%token BINOP
%token ID
%token NUM
%token STRING

%%
program: funcs;
funcs: /*epsilon*/ {$$ = $1;}
     | funcDecl funcs
funcsDecl: retType ID LPAREN formals RPAREN LBRACE statements RBRACE;
retType: type
       | VOID {$$ = $1;};
formals: /*epsilon*/ {$$ = $1;}
       | formalsList;
formalsList: formalDecl
           | formalDecl COMMA formalsList;
formalDecl: typeAnnotation type ID;
statements: statement
          | statements statement;
statement: LBRACE statements RBRACE
         | typeAnnotation type ID SC
         | typeAnnotation type ID ASSIGN exp SC
         | ID ASSIGN exp SC
         | call SC
         | RETURN SC
         | RETURN exp SC
//TODO need to be treated in case of "dangling else" like "statement: IF LPAREN exp RPAREN IF LPAREN exp RPAREN statement ELSE statement;"
         | IF LPAREN exp RPAREN statement {$$ = ($3 == "true" ? $5 : /*epsilon*/);}
         | IF LPAREN exp RPAREN statement ELSE statement {$$ = ($3 == "true" ? $5 : $7);}
         | WHILE LPAREN exp RPAREN statement
         | BREAK SC
         | CONTINUE SC
call: ID LPAREN expList RPAREN
    | ID LPAREN RPAREN;
expList: exp
       | exp COMMA expList;
type: INT {$$ = $1;}
    | BYTE {$$ = $1;}
    | BOOL {$$ = $1;};
typeAnnotation: /*epsilon*/;
              | CONST {$$ = $1;};
exp: LPAREN exp RPAREN {$$ = $2;}
   | exp BINOP exp
   | ID {$$ = $1;}
   | call
   | NUM {$$ = $1;}
   | NUM B
   | STRING {$$ = $1;}
   | TRUE {$$ = $1;}
   | FALSE {$$ = $1; printProductionRule(yylineno);}
   | NOT exp
   | exp AND exp {$$ = ($1 == "true": $3 : $1);}
   | exp OR exp {$$ = ($1 == "true" : $1 : $3);}
   | exp RELOP exp
   | LPAREN typeAnnotation type RPAREN exp;

%%

void yyerror
(const char*) { cout << "syntax error" << endl; }
int main() {
return yyparse();
}